#!/usr/bin/env python3
# Written by Andrej Pakhutin (pakhutin at gmail)
# helper to send/subscribe messages with MQTT
import argparse
import configparser
import json
import os.path
import paho.mqtt.client as mqtt
import re
import signal
import ssl
import sys
import time
import uuid

#############################################################
def handle_termination( signum, frame ):
	if signum == signal.SIGALRM:
		print( "! Special timeout detected. exitting", file = stderr )

	sys.exit(0)

#############################################################
def load_config( c_file ):
	global config

	file = c_file

	if not os.path.exists( file ):
		if re.search( '\/', file ):
			print( "Can't open config: " + file )
			sys.exit(1)

		file = os.path.dirname( sys.argv[0] ) + '/' + c_file

		if not os.path.exists( file ):
			file = '/etc/smarthome/mqtt/' + c_file

	args.debug and print( "+ Loading config: " + file )

	config = configparser.ConfigParser( interpolation = configparser.ExtendedInterpolation() )
	config.read( file )

####################################################
# The callback for debugging
def on_log( client, userdata, level, buf ):
	print ( '+', buf )

####################################################
# The callback for when the client receives a CONNACK response from the server.
def on_connect( client, userdata, flags, rc ):
	global args

	# checking for problems
	if on_connect.connected_on > 0: # reconnect
		if time.time() - on_connect.connected_on < 3.0: # less than 3 sec
			on_connect.fast_reconnects += 1
		else:
			on_connect.fast_reconnects = 0

		if on_connect.fast_reconnects == 3: # lucky number
			print( "! Too many fast reconnects. exitting.", file = stderr )
			sys.exit( 2 )

	on_connect.connected_on = time.time()

####################################################
# global simplifier of things
def connect():
	global args, client_conn, connected, section

	if connected:
		client_conn.disconnect()
		connected = False

	client_conn.connect( section[ 'server' ], port = int( section[ 'port' ] ),
		keepalive = int( section[ 'keepalive' ] ) )

	connected = True

	if args.debug:
		print( "+ Connected" )

	client_conn.loop_start()

####################################################
# The callback for when a PUBLISH message is received from the server.
def on_message( client, userdata, msg ):
	global args, messages_received

	print( '{ "subscription":"' + msg.topic + '", "message":"' + str( msg.payload ).replace( '"', '\"' ) + '" }' )
	messages_received += 1

####################################################
# The callback for when a PUBLISH has been done
def on_publish( client, userdata, mid ):
	if not mid in mids:
		print( '{ "message":"untracked message callback detected", rc:1, "id":' + str( mid ) + ' }' )
		return

	( t, msg ) = mids[ mid ]
	del mids[ mid ]

	if not args.quiet:
		print( '{ "message":"published", "rc":0, "id":' + str( mid ) +
			', "topic":"' + t + '", "payload":"' + msg.replace( '"', '\"' ) + '" }' )

####################################################
def subscribe( client, topic ):
	signal.alarm( 30 ) # there have been some strange delays on sending packets, resulting in hanging processes

	( r, mid ) = client.subscribe( topic, args.qos )

	signal.alarm( 0 )

	if r != mqtt.MQTT_ERR_SUCCESS:
		print( '{ "message":"subscribe failed", "rc":' + str( r ) + ', "topic":"' + topic + '" }' )
		return False

	if not args.oneshot and not args.quiet: # make output simpler for one-time checks
		print( '{ "message":"subscribed", "rc":' + str( r ) + ', "topic":"' + topic + '" }' )

	return True

####################################################
def sub_loop():
	global args, client_conn, messages_received

	client_conn.on_message = on_message

	for t in args.topics:
		if not subscribe( client_conn, t ):
			sys.exit( 1 )

	if not args.oneshot:
		go_stdin()
		sys.exit( 1 ) # should not return normally

	# one shot stuff
	time.sleep( 1 ) # A Generous timeout

	if messages_received == 0:
		print( '{ "message":"empty", "rc":0 }' )

	sys.exit( 0 )

####################################################
def go_stdin():
	global args, client_conn, connected, mids
	client_conn.on_message = on_message
#	client_conn.on_publish = on_publish

	signal.signal( signal.SIGPIPE,  handle_termination )

	line_in = ''

	while True:
		if line_in[ -1: ] == '\\':
			line_in = line_in[ 0:-1 ] + sys.stdin.readline().rstrip()
		else:
			line_in = sys.stdin.readline().rstrip()

		if len( line_in ) == 0 or line_in[ -1: ] == '\\':
			continue

		try:
			j = json.loads( line_in )
		except:
			print( '{ "message":"invalid json", "rc":1 }' )
			continue
		finally:
			line_in = ''

		if args.debug:
			print( "+ json parsed OK" )

		if 'user' in j: # { "user":"name", "password":"..." }
			client_conn.username_pw_set( j['user'], password = j[ 'password' ] if 'password' in j else None )
			continue


		if 'cmd' in j: # specials
			if j['cmd'] == 'exit': # exit/done
				break

		if not connected:
			connect()

		if 'publish' in j or 'mpublish' in j: # { "[m]publish":"message", "topics":[], "retain":bool }
			r = 'retain' in j and j[ 'retain' ]
			q = j[ 'qos' ] if 'qos' in j else 0

			msg = ''
			mode = ''
			if 'publish' in j:
				msg = j[ 'publish' ]
				mode = 'publish'
			else:
				mode = 'mpublish'
				# now read the actual message for mpublish
				while True:
					l = sys.stdin.readline()
					p = l.find( j[ 'mpublish' ] )
					if p >= 0:
						msg += l[ 0:p ]
						break

					msg += l

			for t in j[ 'topics' ]:
				mi = client_conn.publish( t, msg, qos = q, retain = r )
				mi.wait_for_publish()
				#mids[ mi.mid ] = ( t, j['publish'] ) # tracker

				if not args.quiet:
					print( '{ "message":"published", "rc":0, "id":' + str( mi.mid ) +
						', "topic":"' + t + '", "payload":"' + j[ mode ].replace( '"', '\"' ) + '" }' )

		elif 'subscribe' in j: # { "subscribe":[topics] }
			for t in j[ 'subscribe' ]:
				subscribe( client_conn, t )

		elif 'unsubscribe' in j: # { "unsubscribe":[topics] }
			for t in j[ 'unsubscribe' ]:
				( r, mid ) = client_conn.unsubscribe( t )
				if r == mqtt.MQTT_ERR_SUCCESS:
					if not args.quiet:
						print( '{ "message":"unsubsribed", "rc":' + str( r ) + ' }' )
				else:
					print( '{ "message":"unsubsribe failed", "rc":' + str( r ) + ' }' )

		elif 'will' in j: # { "will":"message", "topic":[], "retain":bool, qos:num }
			r = 'retain' in j and j['retain']
			q = j[ 'qos' ] if 'qos' in j else 0

			for t in j['topics']:
				mi = client.will_set( t, payload = j[ 'will' ], qos = q, retain = r )

				if not args.quiet:
					print( '{ "message":"will set", "rc":0, "id":' + str( mi.mid ) +
						', "topic":"' + t + '", "payload":"' + j[ 'will' ].replace( '"', '\"' ) + '" }' )

		else:
			print( '{ "message":"unknown command", "rc":1 }' )

	signal.alarm( 30 ) # there have been some strange delays on sending packets, resulting in hanging processes
	client_conn.disconnect()

	sys.exit( 0 )

####################################################
####################################################
global args, config, connected, client_conn, messages_received, mids, section

config_path = '/etc/smarthome/mqtt/mqtt.ini' # default
connected = False # for handling stuff in stdin mode
mids = dict() # to track messages in stdin mode
messages_received = 0 # to check if we got answer for one-shot sub
on_connect.fast_reconnects = 0 # how many attempts to reconect were within the short time period
on_connect.connected_on = 0 # time()
####################################################

parser = argparse.ArgumentParser( description = 'Send or subscribe to mqtt messages' )

parser.add_argument( '-c', '--config', dest = 'config_path', action = 'store', default = config_path, help = 'path to non-default (' + config_path + ') config file')
parser.add_argument( '--clientid', dest = 'clientid', action = 'store', default = '', help = 'Overrides clientid from .ini and autogenerated one')
parser.add_argument( '-d', '--debug', dest = 'debug', action = 'store_true', default = False,  help = 'debug mode')
parser.add_argument( '-i', '--stdin', dest = 'stdin_mode', action = 'store_true', default = False, help = 'work in stdin mode, accepting multiple commands in json' )
parser.add_argument( '-m', '--message', dest = 'message', action = 'store', help = 'message to send' )
parser.add_argument( '--oneshot', dest = 'oneshot', action = 'store_true', default = False, help = 'Use with -s (subscribe) to get the first message only' )
parser.add_argument( '-r', '--retain', dest = 'retain', action = 'store_true', default = False, help = 'retain mode' )
parser.add_argument( '-s', '--subscribe', dest = 'subscribe', action = 'store_true', default = False, help = 'subscribe to topic(s)' )
parser.add_argument( '-t', '--topic', dest = 'topics', action = 'append', help = 'topic to send to or topic(s) to subscribe (may be repeated)' )
parser.add_argument( '-u', '--user', dest = 'username', action = 'store', default = '', help = 'user name' )
parser.add_argument( '-p', '--password', dest = 'password', action = 'store', default = None, help = 'password (if you willing to show it in processes)' )
parser.add_argument( '-q', '--qos', dest = 'qos', action = 'store', type = int, default = 0, help = 'QoS code (0,1,2)' )
parser.add_argument( '--quiet', dest = 'quiet', action = 'store_true', default = False, help = 'do not print operations acknowledge messages' )
parser.add_argument( 'section', nargs = '?', default = '', help = 'Use this .ini section name' )

args = parser.parse_args()

load_config( args.config_path )

section = args.section
if section == '':
	section = config[ 'DEFAULT' ][ 'server' ]

if not section in config:
	print( "! Section name", section, " not in", config_path )
	sys.exit( 1 )

if args.debug:
	print( "Using .ini section: ", section )

section = config[ section ]

if args.debug:
	for i in section:
		print( '     "' + i + '" = "' + section[ i ] + '"')

cid = ''
if args.clientid != '':
	cid = args.clientid
elif 'clientid' in section:
	cid = section[ 'clientid' ]
else:
	cid = 'mqtt-tool-' + str( uuid.uuid4() )

signal.signal( signal.SIGALRM, handle_termination )

client_conn = mqtt.Client( cid )
client_conn.on_connect = on_connect

if args.debug:
	client_conn.on_log = on_log
	client_conn.enable_logger()

authmode = ''
if args.username != '': # use to switch ACLs
	client_conn.username_pw_set( args.username, password = args.password )
	authmode = 'user/pass override from commandline'
elif 'auth' in section and section[ 'auth' ] == 'user':
	client_conn.username_pw_set( section[ 'user' ], password = section[ 'pass' ] )
	authmode = 'user/pass from .ini'

if 'auth' in section and section[ 'auth' ] == 'ssl':
	authmode = 'SSL from .ini'

	# setting some defaults:
	if not 'port' in section:
		section[ 'port' ] = '8883'

	#context = ssl.create_default_context()
	#context.verify_mode = ssl.CERT_REQUIRED
	#context.check_hostname = True
	#context.load_default_certs()
	#client_conn.tls_set_context( context )

	client_conn.tls_set(
		ca_certs = section[ 'cafile' ],
		certfile = section[ 'crt' ],
		keyfile  = section[ 'key' ],
		cert_reqs = ssl.CERT_REQUIRED,
		tls_version = ssl.PROTOCOL_TLS,
		ciphers = None
		#SSL_ca_path   => config[ sever ][ 'capath' ]
	)
else: # not SSL. note that user/pass already set when we checked for command line override
	# setting some defaults:
	if not 'port' in section:
		section[ 'port' ] = '1883'

if authmode == '':
	print( "! ERROR: authentication mode were not set. Check you .ini and/or command line!" )
	sys.exit(1)

if args.debug:
	print( "+ auth mode:", authmode )

if not 'keepalive' in section:
	section[ 'keepalive' ] = '20'

#--------------------------------------------
if args.stdin_mode:
	go_stdin()

#--------------------------------------------
if args.topics == None:
	print( "Topic(s) are undefined!" )
	parser.print_help()
	sys.exit(1)

connect()

if args.subscribe:
	sub_loop()
	sys.exit(1)

#--------------------------------------------
if args.message == None:
	print( "! Message is not provided!" )
	parser.print_help()
	sys.exit(1);

for t in args.topics:
	signal.alarm( 30 ) # there have been some strange delays on sending packets, resulting in hanging processes

	try:
		client_conn.publish( t, args.message, retain = args.retain, qos = args.qos ).wait_for_publish()
		if args.debug:
			print( "published to " + t + " - " + args.message )
	except:
		break

client_conn.disconnect()
