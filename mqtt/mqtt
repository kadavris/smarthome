#!/usr/bin/env python3
# Written by Andrej Pakhutin (pakhutin at gmail)
# helper to send/subscribe messages with MQTT
import argparse
import configparser
import json
import os.path
import paho.mqtt.client as mqtt
import re
import ssl
import sys
import time

#############################################################
# do 'base=' inheritance
def config_rebase( section_name ):
	global c_r_stack

	if section_name in c_r_stack:
		print( '! ERROR: base= loop detected in .ini with', section_name )
		sys.exit( 1 )

	if not 'base' in config[ section_name ]:
		return

	base_name = config[ section_name ][ 'base' ]

	# rebase the base ;)
	c_r_stack.append( section_name )
	config_rebase( base_name )
	c_r_stack.pop()

	# now copy all missing keys from base
	if args.debug:
		print( 'rebasing', section_name, 'from', base_name )

	for k in config[ base_name ]:
		if not k in config[ section_name ]:
			config[ section_name ][ k ] = config[ base_name ][ k ].replace( '%', '%%' )
			if args.debug:
				print( '\trebased key ', k, '=', config[ section_name ][ k ] )

#############################################################
def load_config( c_file ):
	global config, c_r_stack

	file = c_file

	if not os.path.exists( file ):
		if re.search( '\/', file ):
			print( "Can't open config: " + file )
			sys.exit(1)

		file = os.path.dirname( sys.argv[0] ) + '/' + c_file

		if not os.path.exists( file ):
			file = '/etc/smarthome/mqtt/' + c_file

	args.debug and print( "+ Loading config: " + file )

	config = configparser.ConfigParser()
	config.read( file )

	c_r_stack = []
	for sec in config.sections():
		config_rebase( sec )

####################################################
# The callback for debugging
def on_log( client, userdata, level, buf ):
	print ( '+', buf )

####################################################
# The callback for when the client receives a CONNACK response from the server.
def on_connect( client, userdata, flags, rc ):
	global args

	pass

####################################################
# global simplifier of things
def connect():
	global args, config, client_conn, connected, server

	client_conn.on_connect = on_connect

	if connected:
		client_conn.disconnect()
		connected = False

	client_conn.connect( config[ server ][ 'server' ], port = int( config[ server ][ 'port' ] ),
		keepalive = int( config[ server ][ 'keepalive' ] ) )

	connected = True

	if args.debug:
		print( "+ Connected" )

	client_conn.loop_start()

####################################################
# The callback for when a PUBLISH message is received from the server.
def on_message( client, userdata, msg ):
	global args, messages_received

	print( '{ "subscription":"' + msg.topic + '", "message":"' + str( msg.payload ).replace( '"', '\"' ) + '" }' )
	messages_received += 1

####################################################
# The callback for when a PUBLISH has been done
def on_publish( client, userdata, mid ):
	if not mid in mids:
		print( '{ "message":"untracked message callback detected", rc:1, "id":' + str( mid ) + ' }' )
		return

	( t, msg ) = mids[ mid ]
	del mids[ mid ]

	if not args.quiet:
		print( '{ "message":"published", "rc":0, "id":' + str( mid ) +
			', "topic":"' + t + '", "payload":"' + msg.replace( '"', '\"' ) + '" }' )

####################################################
def subscribe( client, topic ):
	( r, mid ) = client.subscribe( topic, args.qos )
	if r != mqtt.MQTT_ERR_SUCCESS:
		print( '{ "message":"subscribe failed", "rc":' + str( r ) + ', "topic":"' + topic + '" }' )
		return False

	if not args.oneshot and not args.quiet: # make output simpler for one-time checks
		print( '{ "message":"subscribed", "rc":' + str( r ) + ', "topic":"' + topic + '" }' )

	return True

####################################################
def sub_loop():
	global args, client_conn, messages_received

	client_conn.on_message = on_message

	for t in args.topics:
		if not subscribe( client_conn, t ):
			sys.exit( 1 )

	if not args.oneshot:
		go_stdin()
		sys.exit( 1 ) # should not return normally

	# one shot stuff
	time.sleep( 1 ) # A Generous timeout

	if messages_received == 0:
		print( '{ "message":"empty", "rc":0 }' )

	sys.exit( 0 )

####################################################
def go_stdin():
	global args, client_conn, connected, mids
	client_conn.on_message = on_message
#	client_conn.on_publish = on_publish

	while not sys.stdin.closed:
		l = sys.stdin.readline()

		if len( l ) == 0:
			continue

		try:
			j = json.loads( l )
		except:
			print( '{ "message":"invalid json", "rc":1 }' )
			continue

		if args.debug:
			print( "+ json parsed OK" )

		if 'user' in j: # { "user":"name", "password":"..." }
			client_conn.username_pw_set( j['user'], password = j[ 'password' ] if 'password' in j else None )
			continue


		if 'cmd' in j: # specials
			if j['cmd'] == 'exit': # exit/done
				break

		if not connected:
			connect()

		if 'publish' in j or 'mpublish' in j: # { "[m]publish":"message", "topics":[], "retain":bool }
			r = 'retain' in j and j[ 'retain' ]
			q = j[ 'qos' ] if 'qos' in j else 0

			msg = ''
			mode = ''
			if 'publish' in j:
				msg = j[ 'publish' ]
				mode = 'publish'
			else:
				mode = 'mpublish'
				# now read the actual message for mpublish
				while True:
					l = sys.stdin.readline()
					p = l.find( j[ 'mpublish' ] )
					if p >= 0:
						msg += l[ 0:p ]
						break

					msg += l

			for t in j[ 'topics' ]:
				mi = client_conn.publish( t, msg, qos = q, retain = r )
				mi.wait_for_publish()
				#mids[ mi.mid ] = ( t, j['publish'] ) # tracker

				if not args.quiet:
					print( '{ "message":"published", "rc":0, "id":' + str( mi.mid ) +
						', "topic":"' + t + '", "payload":"' + j[ mode ].replace( '"', '\"' ) + '" }' )

		elif 'subscribe' in j: # { "subscribe":[topics] }
			for t in j[ 'subscribe' ]:
				subscribe( client_conn, t )

		elif 'unsubscribe' in j: # { "unsubscribe":[topics] }
			for t in j[ 'unsubscribe' ]:
				( r, mid ) = client_conn.unsubscribe( t )
				if r == mqtt.MQTT_ERR_SUCCESS:
					if not args.quiet:
						print( '{ "message":"unsubsribed", "rc":' + str( r ) + ' }' )
				else:
					print( '{ "message":"unsubsribe failed", "rc":' + str( r ) + ' }' )

		elif 'will' in j: # { "will":"message", "topic":[], "retain":bool, qos:num }
			r = 'retain' in j and j['retain']
			q = j[ 'qos' ] if 'qos' in j else 0

			for t in j['topics']:
				mi = client.will_set( t, payload = j[ 'will' ], qos = q, retain = r )

				if not args.quiet:
					print( '{ "message":"will set", "rc":0, "id":' + str( mi.mid ) +
						', "topic":"' + t + '", "payload":"' + j[ 'will' ].replace( '"', '\"' ) + '" }' )

		else:
			print( '{ "message":"unknown command", "rc":1 }' )

	client_conn.loop_stop()

	client_conn.disconnect()

	sys.exit( 0 )

####################################################
####################################################
global args, config, connected, client_conn, messages_received, mids, server

config_path = '/etc/smarthome/mqtt/mqtt.ini' # default
connected = False # for handling stuff in stdin mode
mids = dict() # to track messages in stdin mode
messages_received = 0

####################################################

parser = argparse.ArgumentParser( description = 'Send or subscribe to mqtt messages' )

parser.add_argument( '-c', '--config', dest = 'config_path', action = 'store', default = config_path, help = 'path to non-default (' + config_path + ') config file')
parser.add_argument( '--client-id', dest = 'client_id', action = 'store', default = '', help = 'Overrides clientid from .ini and autogenerated one')
parser.add_argument( '-d', '--debug', dest = 'debug', action = 'store_true', default = False,  help = 'debug mode')
parser.add_argument( '-i', '--stdin', dest = 'stdin_mode', action = 'store_true', default = False, help = 'work in stdin mode, accepting multiple commands in json' )
parser.add_argument( '-m', '--message', dest = 'message', action = 'store', help = 'message to send' )
parser.add_argument( '--oneshot', dest = 'oneshot', action = 'store_true', default = False, help = 'Use with -s (subscribe) to get the first message only' )
parser.add_argument( '-r', '--retain', dest = 'retain', action = 'store_true', default = False, help = 'retain mode' )
parser.add_argument( '-s', '--subscribe', dest = 'subscribe', action = 'store_true', default = False, help = 'subscribe to topic(s)' )
parser.add_argument( '-t', '--topic', dest = 'topics', action = 'append', help = 'topic to send to or topic(s) to subscribe (may be repeated)' )
parser.add_argument( '-u', '--user', dest = 'username', action = 'store', default = '', help = 'user name' )
parser.add_argument( '-p', '--password', dest = 'password', action = 'store', default = None, help = 'password (if you willing to show it in processes)' )
parser.add_argument( '-q', '--qos', dest = 'qos', action = 'store', type = int, default = 0, help = 'QoS code (0,1,2)' )
parser.add_argument( '--quiet', dest = 'quiet', action = 'store_true', default = False, help = 'do not print operations acknowledge messages' )
parser.add_argument( 'server', nargs = '?', default = '', help = 'server name, if not from DEFAULT .ini section' )

args = parser.parse_args()

load_config( args.config_path );

server = args.server
if server == '': #get default
	server = config[ 'DEFAULT' ][ 'server' ]

if not server in config:
	print( "! Server", server, " not in", config_path )
	sys.exit( 1 )

if args.debug:
	print( "Server", server )

if args.debug:
	for s in config:
		print( 'section "' + s + '"')
		for i in config[s]:
			print( '     "' + i + '" = "' + config[s][i] + '"')

cid = ''
if args.client_id != '':
	cid = args.client_id
elif 'clientid' in config[ server ]:
	cid = config[ server ][ 'clientid' ]
else:
	cid = 'mqtt-tool'

client_conn = mqtt.Client( cid )
if args.debug:
	client_conn.on_log = on_log
	client_conn.enable_logger()

authmode = ''
if args.username != '': # use to switch ACLs
	client_conn.username_pw_set( args.username, password = args.password )
	authmode = 'user/pass override from commandline'
elif 'auth' in config[ server ] and config[ server ][ 'auth' ] == 'user':
	client_conn.username_pw_set( config[ server ][ 'user' ], password = config[ server ][ 'pass' ] )
	authmode = 'user/pass from .ini'

if 'auth' in config[ server ] and config[ server ][ 'auth' ] == 'ssl':
	authmode = 'SSL from .ini'

	# setting some defaults:
	if not 'port' in config[ server ]:
		config[ server ][ 'port' ] = '8883'

	#context = ssl.create_default_context()
	#context.verify_mode = ssl.CERT_REQUIRED
	#context.check_hostname = True
	#context.load_default_certs()
	#client_conn.tls_set_context( context )

	client_conn.tls_set(
		ca_certs = config[ server ][ 'cafile' ],
		certfile = config[ server ][ 'crt' ],
		keyfile  = config[ server ][ 'key' ],
		cert_reqs = ssl.CERT_REQUIRED,
		tls_version = ssl.PROTOCOL_TLS,
		ciphers = None
		#SSL_ca_path   => config[ sever ][ 'capath' ]
	)
else: # not SSL. note that user/pass already set when we checked for command line override
	# setting some defaults:
	if not 'port' in config[ server ]:
		config[ server ][ 'port' ] = '1883'

if authmode == '':
	print( "! ERROR: authentication mode were not set. Check you .ini and/or command line!" )
	sys.exit(1)

if args.debug:
	print( "+ auth mode:", authmode )

if not 'keepalive' in config[ server ]:
	config[ server ][ 'keepalive' ] = '20'

#--------------------------------------------
if args.stdin_mode:
	go_stdin()

#--------------------------------------------
if args.topics == None:
	print( "Topic(s) are undefined!" )
	parser.print_help()
	sys.exit(1)

connect()

if args.subscribe:
	sub_loop()
	sys.exit(1)

#--------------------------------------------
if args.message == None:
	print( "! Message is not provided!" )
	parser.print_help()
	sys.exit(1);

for t in args.topics:
	try:
		client_conn.publish( t, args.message, retain = args.retain, qos = args.qos ).wait_for_publish()
		if args.debug:
			print( "published to " + t + " - " + args.message )
	except:
		break

client_conn.disconnect()
